---

- name: Sanity check (S3 backup)
  assert:
    that:
    - pg_bu_s3_bucket_name|string|length > 0
    - pg_bu_s3_access_key_id|string|length > 0
    - pg_bu_s3_secret_access_key|string|length > 0
  when: pg_bu_volume_is_s3|bool

- name: Sanity check (backup order)
  assert:
    that:
    - pg_bu_daily_history|int > 0
  when: pg_bu_weekly_history|int > 0

# Namespace and basic material ------------------------------------------------

- name: Create namespace ({{ infra_namespace }})
  k8s:
    definition: "{{ lookup('template', 'namespace-im-infra.yaml.j2') }}"

- name: Create DockerHub image pull secret
  k8s:
    definition: "{{ lookup('template', 'secret-dh-imagepull.yaml.j2') }}"
    wait: yes
  vars:
    pull_namespace: "{{ infra_namespace }}"
    pull_secret: "{{ infra_dockerhub_pullsecret }}"
  when: infra_dockerhub_pullsecret|string|length > 0

- name: Create SA
  k8s:
    definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
    wait: yes
  loop:
  - serviceaccount-im-infra

- name: Create PSP
  k8s:
    definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
    wait: yes
  loop:
  - role-im-psp-unrestricted
  - rolebinding-im-infra-sa
  when: k8s_use_psp|bool

- name: Relax {{ infra_namespace }} 'default' service account (for cert-manager)
  k8s:
    definition: "{{ lookup('template', 'rolebinding-default-sa.yaml.j2') }}"
    wait: yes
  when: cm_state|string == 'present'

# Secrets (optional S3 secrets) -----------------------------------------------

- block:

  - name: Check S3 variables
    assert:
      that:
      - pg_bu_s3_access_key_id|string|length > 0
      - pg_bu_s3_default_region|string|length > 0
      - pg_bu_s3_secret_access_key|string|length > 0
      fail_msg: >-
        You have provided a value for 'pg_bu_s3_bucket_name'.
        You must provide values for all the other 'pg_bu_s3_' variables.

  - name: Check S3 secrets
    kubernetes.core.k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-s3
    register: s3_s_result

  - name: Set S3 secret facts
    set_fact:
      pg_bu_s3_default_region_fact: "{{ pg_bu_s3_default_region }}"
      pg_bu_s3_access_key_id_fact: "{{ pg_bu_s3_access_key_id }}"
      pg_bu_s3_secret_access_key_fact: "{{ pg_bu_s3_secret_access_key }}"
    when: s3_s_result.resources|length == 0

  - name: Set S3 secret facts (pre-deployed secrets)
    set_fact:
      pg_bu_s3_default_region_fact: "{{ s3_s_result.resources[0].data.default_region|b64decode }}"
      pg_bu_s3_access_key_id_fact: "{{ s3_s_result.resources[0].data.access_key_id|b64decode }}"
      pg_bu_s3_secret_access_key_fact: "{{ s3_s_result.resources[0].data.secret_access_key|b64decode }}"
    when: s3_s_result.resources|length == 1

  - name: Write S3 secrets
    k8s:
      definition: "{{ lookup('template', 'secret-s3.yaml.j2') }}"
      wait: yes
    when: s3_s_result.resources|length == 0

  when: pg_bu_s3_bucket_name|string|length > 0

# Secrets (database) ----------------------------------------------------------

- name: Database Secrets
  block:

  - name: Check database (postgres) secrets
    kubernetes.core.k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-postgres
    register: pg_s_result

  - name: Set database secret facts
    set_fact:
      pg_user_fact: "{{ pg_user }}"
      pg_user_password_fact: "{{ pg_user_password }}"
      pg_database_fact: "{{ pg_database }}"
    when: pg_s_result.resources|length == 0

  - name: Set database secret facts (pre-deployed secrets)
    set_fact:
      pg_user_fact: "{{ pg_s_result.resources[0].data.database_admin_user|b64decode }}"
      pg_user_password_fact: "{{ pg_s_result.resources[0].data.database_admin_user_password|b64decode }}"
      pg_database_fact: "{{ pg_s_result.resources[0].data.database_name|b64decode }}"
    when: pg_s_result.resources|length == 1

  - name: Write Database secrets
    k8s:
      definition: "{{ lookup('template', 'secret-postgres.yaml.j2') }}"
      wait: yes
    when: pg_s_result.resources|length == 0

  - name: Display Database admin password
    debug:
      var: pg_user_password_fact

  when: pg_state|string == 'present'

# Secrets (AWX database) ------------------------------------------------------

- name: AWX database secret
  block:

  - name: Check AWX database secrets
    kubernetes.core.k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-awx
    register: awx_s_result

  - name: Set AWX database secret facts
    set_fact:
      ax_user_fact: "{{ ax_user }}"
      ax_user_password_fact: "{{ ax_user_password }}"
      ax_database_fact: "{{ ax_database }}"
      ax_admin_fact: "{{ ax_admin }}"
      ax_admin_password_fact: "{{ ax_admin_password }}"
    when: awx_s_result.resources|length == 0

  - name: Set AWX database secret facts (pre-deployed secrets)
    set_fact:
      ax_user_fact: "{{ awx_s_result.resources[0].data.database_user|b64decode }}"
      ax_user_password_fact: "{{ awx_s_result.resources[0].data.database_user_password|b64decode }}"
      ax_database_fact: "{{ awx_s_result.resources[0].data.database_name|b64decode }}"
      ax_admin_fact: "{{ awx_s_result.resources[0].data.ax_admin|b64decode }}"
      ax_admin_password_fact: "{{ awx_s_result.resources[0].data.ax_admin_password|b64decode }}"
    when: awx_s_result.resources|length == 1

  - name: Write AWX database secrets
    k8s:
      definition: "{{ lookup('template', 'secret-awx.yaml.j2') }}"
      wait: yes
    when: awx_s_result.resources|length == 0

  - name: Display AWX database password
    debug:
      var: ax_user_password_fact

  - name: Display AWX console admin user and password
    debug:
      msg: AWX console admin user - {{ ax_admin_fact }}/{{ ax_admin_password_fact }}

  when: ax_state|string == 'present'

# Secrets (Keycloak) ----------------------------------------------------------

- name: Keyclock secret
  block:

  - name: Check Keycloak secrets
    kubernetes.core.k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-keycloak
    register: kc_s_result

  - name: Set Keycloak secret facts
    set_fact:
      kc_user_fact: "{{ kc_user }}"
      kc_user_password_fact: "{{ kc_user_password }}"
      kc_database_fact: "{{ kc_database }}"
      kc_hostname_fact: "{{ kc_hostname }}"
      kc_admin_fact: "{{ kc_admin }}"
      kc_admin_password_fact: "{{ kc_admin_password }}"
    when: kc_s_result.resources|length == 0

  - name: Set Keycloak secret facts (pre-deployed secrets)
    set_fact:
      kc_user_fact: "{{ kc_s_result.resources[0].data.database_user|b64decode }}"
      kc_user_password_fact: "{{ kc_s_result.resources[0].data.database_user_password|b64decode }}"
      kc_database_fact: "{{ kc_s_result.resources[0].data.database_name|b64decode }}"
      kc_hostname_fact: "{{ kc_s_result.resources[0].data.keycloak_hostname|b64decode }}"
      kc_admin_fact: "{{ kc_s_result.resources[0].data.keycloak_admin_user|b64decode }}"
      kc_admin_password_fact: "{{ kc_s_result.resources[0].data.keycloak_admin_user_password|b64decode }}"
    when: kc_s_result.resources|length == 1

  - name: Write Keycloak secrets
    k8s:
      definition: "{{ lookup('template', 'secret-keycloak.yaml.j2') }}"
      wait: yes
    when: kc_s_result.resources|length == 0

  - name: Display Keycloak database password
    debug:
      var: kc_user_password_fact

  - name: Display Keycloak admin password
    debug:
      var: kc_admin_password_fact

  when: kc_state|string == 'present'

# Secrets (Squonk2 DM) ------------------------------------------------------

- name: Create DM Secret
  block:

  - name: Check DM database secrets
    k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-data-manager
    register: dm_s_result
    when: dm_database_user|string|length > 0

  - name: Set DM database secret facts
    set_fact:
      dm_user_fact: "{{ dm_database_user }}"
      dm_user_password_fact: "{{ dm_database_user_password }}"
      dm_database_fact: "{{ dm_database }}"
    when: dm_s_result.resources|length == 0

  - name: Set DM database secret facts (pre-deployed secrets)
    set_fact:
      dm_user_fact: "{{ dm_s_result.resources[0].data.database_user|b64decode }}"
      dm_user_password_fact: "{{ dm_s_result.resources[0].data.database_user_password|b64decode }}"
      dm_database_fact: "{{ dm_s_result.resources[0].data.database_name|b64decode }}"
    when: dm_s_result.resources|length == 1

  - name: Write DM database secrets
    k8s:
      definition: "{{ lookup('template', 'secret-data-manager.yaml.j2') }}"
      wait: yes
    when: dm_s_result.resources|length == 0

  when: dm_database_user|string|length > 0

# Secrets (Squonk2 AS) ------------------------------------------------------

- name: Create AS Secret
  block:

  - name: Check AS database secrets
    k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: im-account-server
    register: as_s_result

  - name: Set AS database secret facts
    set_fact:
      as_user_fact: "{{ as_database_user }}"
      as_user_password_fact: "{{ as_database_user_password }}"
      as_database_fact: "{{ as_database }}"
    when: as_s_result.resources|length == 0

  - name: Set AS database secret facts (pre-deployed secrets)
    set_fact:
      as_user_fact: "{{ as_s_result.resources[0].data.database_user|b64decode }}"
      as_user_password_fact: "{{ as_s_result.resources[0].data.database_user_password|b64decode }}"
      as_database_fact: "{{ as_s_result.resources[0].data.database_name|b64decode }}"
    when: as_s_result.resources|length == 1

  - name: Write AS database secrets
    k8s:
      definition: "{{ lookup('template', 'secret-account-server.yaml.j2') }}"
      wait: yes
    when: as_s_result.resources|length == 0

  when: as_database_user|string|length > 0

# Secrets (RabbitMQ) ----------------------------------------------------------

- name: Create RabbitMQ Secret
  block:

  - name: Check RabbitMQ secrets
    k8s_info:
      kind: Secret
      api_version: v1
      namespace: "{{ infra_namespace }}"
      name: rabbitmq
    register: rmq_s_result

  - name: Set RabbitMQ secret facts
    set_fact:
      rabbitmq_user_fact: "{{ rabbitmq_user }}"
      rabbitmq_user_password_fact: "{{ rabbitmq_user_password }}"
      rabbitmq_erlang_cookie_fact: "{{ rabbitmq_erlang_cookie }}"
    when: rmq_s_result.resources|length == 0

  - name: Set RabbitMQ secret facts (pre-deployed secrets)
    set_fact:
      rabbitmq_user_fact: "{{ rmq_s_result.resources[0].user|b64decode }}"
      rabbitmq_user_password_fact: "{{ rmq_s_result.resources[0].data.password|b64decode }}"
      rabbitmq_database_fact: "{{ rmq_s_result.resources[0].erlang_cookie|b64decode }}"
    when: rmq_s_result.resources|length == 1

  - name: Write RabbitMQ secrets
    k8s:
      definition: "{{ lookup('template', 'secret-rabbitmq.yaml.j2') }}"
      wait: yes
    when: rmq_s_result.resources|length == 0

  when: rabbitmq_state|string == 'present'

# Database (postgres) ---------------------------------------------------------

- name: Postgres
  block:

  - name: Get {{ pg_vol_storageclass }} StorageClass
    kubernetes.core.k8s_info:
      kind: StorageClass
      name: "{{ pg_vol_storageclass }}"
    register: sc_result
    when: pg_vol_storageclass != " "

  - name: Assert {{ pg_vol_storageclass }} StorageClass
    assert:
      that: sc_result.resources|length == 1
      fail_msg: The {{ pg_vol_storageclass }} StorageClass must be available on the cluster
    when: pg_vol_storageclass != " "

  - name: Create postgres volume claim ({{ pg_vol_storageclass }})
    k8s:
      definition: "{{ lookup('template', 'pvc-postgres.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"

  # Best practice ... wait for the PVC to bind.
  # e.g. wait until resources[0].status.phase == Bound (initially Pending)

  - name: Wait for postgres volume claim to bind
    kubernetes.core.k8s_info:
      kind: PersistentVolumeClaim
      name: pg
      namespace: "{{ infra_namespace }}"
    register: pg_pvc_result
    until: >-
      pg_pvc_result.resources|length > 0
      and pg_pvc_result.resources[0].status is defined
      and pg_pvc_result.resources[0].status.phase is defined
      and pg_pvc_result.resources[0].status.phase == 'Bound'
    delay: 5
    retries: "{{ (bind_timeout|int / 5)|int }}"
    when: wait_for_bind|bool

  - name: Postgres
    k8s:
      definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    loop:
    - configmap-postgres-conf
    - configmap-postgres-init
    - service-postgres
    - statefulset-postgres

  - name: Wait for postgres to become Ready
    kubernetes.core.k8s_info:
      kind: Pod
      name: database-0
      namespace: "{{ infra_namespace }}"
    register: database_result
    until: >-
      database_result.resources|length == 1
      and database_result.resources[0].status is defined
      and database_result.resources[0].status.containerStatuses is defined
      and database_result.resources[0].status.containerStatuses|length == 1
      and database_result.resources[0].status.containerStatuses[0].ready
    delay: 30
    retries: "{{ (wait_timeout|int / 30)|int }}"

  when: pg_state|string == 'present'

# Database (backups) ----------------------------------------------------------

- name: Database backup
  block:

  - name: Get {{ pg_bu_vol_storageclass }} StorageClass
    kubernetes.core.k8s_info:
      kind: StorageClass
      name: "{{ pg_bu_vol_storageclass }}"
    register: sc_result
    when:
    - not pg_bu_volume_is_s3|bool
    - pg_bu_vol_storageclass != " "

  - name: Assert {{ pg_bu_vol_storageclass }} StorageClass
    assert:
      that: sc_result.resources|length == 1
      fail_msg: The {{ pg_bu_vol_storageclass }} StorageClass must be available on the cluster
    when:
    - not pg_bu_volume_is_s3|bool
    - pg_bu_vol_storageclass != " "

  - name: Create postgres backup volume claim ({{ pg_bu_vol_storageclass }})
    k8s:
      definition: "{{ lookup('template', 'pvc-postgres-backup.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    when: not pg_bu_volume_is_s3|bool

  - name: Wait for postgres backup volume claim to bind
    kubernetes.core.k8s_info:
      kind: PersistentVolumeClaim
      name: pg-bu
      namespace: "{{ infra_namespace }}"
    register: pg_bu_pvc_result
    until: pg_bu_pvc_result.resources[0].status.phase == 'Bound'
    delay: 5
    retries: "{{ (bind_timeout|int / 5)|int }}"
    when:
    - not pg_bu_volume_is_s3|bool
    - wait_for_bind|bool

  - name: Deploy backup (hourly)
    k8s:
      definition: "{{ lookup('template', 'cronjob-postgres-backup-hourly.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"

  - name: Deploy backup (daily)
    k8s:
      definition: "{{ lookup('template', 'cronjob-postgres-backup-daily.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    when: pg_bu_daily_history|int > 0

  - name: Deploy backup (weekly)
    k8s:
      definition: "{{ lookup('template', 'cronjob-postgres-backup-weekly.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    when: pg_bu_weekly_history|int > 0

  when: pg_bu_state|string == 'present'

# AWX -------------------------------------------------------------------------

# Check the AWX StatefulSet existence.
# If it's already present we do not re-render or deploy.

- name: Deploy AWX
  block:

  - name: AWX assertions
    assert:
      that:
      - ax_cert_issuer in cert_issuer_set

  # Extract current AWX version.
  # If it's different then force a re-deploy,
  # otherwise skip the AWX stage.

  - name: Check AWX stateful set
    kubernetes.core.k8s_info:
      kind: StatefulSet
      namespace: "{{ infra_namespace }}"
      name: awx
    register: ax_ss_result

  - name: Get awx-web image string
    set_fact:
      awx_data: "{{ ax_ss_result.resources[0]|json_query(query) }}"
    vars:
      query: spec.template.spec.containers[?name=='awx-web'].image
    when:
    - ax_ss_result.resources|length == 1

  - name: Extract awx-web version
    set_fact:
      current_awx_version: "{{ awx_data[0].split(':')[1] }}"
    when:
    - awx_data is defined
    - awx_data|length == 1
    - awx_data[0]|string|length > 0

  - name: Check for AWX version change
    set_fact:
      awx_version_change: >-
        {{ not current_awx_version is defined
        or ax_version != current_awx_version }}

  # Installation block (if there's a version change)

  - name: AWX installation block
    block:

    - name: AWX pre-flight check
      assert:
        that:
        - ax_admin|length > 0
        - ax_admin != 'SetMe'
        - ax_admin_password|length > 0
        - ax_admin_password != 'SetMe'

    - name: Ensure AWX clone directory
      file:
        path: "{{ ax_clone_dir }}"
        state: directory
        mode: '0755'

    - name: Remove existing AWX clone directory
      file:
        path: "{{ ax_clone_dir }}/awx"
        state: absent

    - name: Clone AWX {{ ax_version }} (into {{ ax_clone_dir }})
      git:
        repo: https://github.com/ansible/awx.git
        dest: "{{ ax_clone_dir }}/awx"
        version: "{{ ax_version }}"
        force: yes

    - name: Set AWX inventory file fact
      set_fact:
        inventory_file: "{{ ax_clone_dir }}/awx/installer/inventory"

    - import_tasks: render-awx-{{ ax_version }}-{{ ax_platform }}.yaml

    # Now that the cloned installation has been rendered
    # for the chosen AWX version and platform, run the installer (asynchronously),
    # giving it up to 15 minutes to complete...

    # We need to provide ability for AWX service account
    # to act in the infrastructure namespace.

    - name: Relax {{ infra_namespace }} 'awx' service account
      k8s:
        definition: "{{ lookup('template', 'rolebinding-awx-sa.yaml.j2') }}"
        wait: yes

    - name: Deploy AWX (into {{ infra_namespace }})
      command: ansible-playbook -i inventory install.yml
      changed_when: false
      args:
        chdir: "{{ ax_clone_dir }}/awx/installer"
      async: "{{ 15 * 60 }}"

    when: awx_version_change|bool

  when: ax_state|string == 'present'

# Keycloak --------------------------------------------------------------------

- name: Deploy Keycloak
  block:

  - name: Keycloak assertions
    assert:
      that:
      - kc_cert_issuer in cert_issuer_set

  - name: Keycloak
    k8s:
      definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    loop:
    - service-keycloak
    - ingress-keycloak
    - statefulset-keycloak

  - name: Wait for keycloak to become Ready ({{ wait_timeout }} seconds)
    kubernetes.core.k8s_info:
      kind: Pod
      name: keycloak-0
      namespace: "{{ infra_namespace }}"
    register: keycloak_result
    until: >-
      keycloak_result.resources|length == 1
      and keycloak_result.resources[0].status is defined
      and keycloak_result.resources[0].status.containerStatuses is defined
      and keycloak_result.resources[0].status.containerStatuses|length == 1
      and keycloak_result.resources[0].status.containerStatuses[0].ready
    delay: 30
    retries: "{{ (wait_timeout|int / 30)|int }}"

  when: kc_state|string == 'present'

# RabbitMQ --------------------------------------------------------------------

- name: Deploy RabbitMQ
  block:

  - name: RabbitMQ assertions
    assert:
      that:
      - kc_cert_issuer in cert_issuer_set

  - name: Get {{ rabbitmq_vol_storageclass }} StorageClass
    kubernetes.core.k8s_info:
      kind: StorageClass
      name: "{{ rabbitmq_vol_storageclass }}"
    register: sc_result
    when: rabbitmq_vol_storageclass != " "

  - name: Assert {{ pg_vol_storageclass }} StorageClass
    assert:
      that: sc_result.resources|length == 1
      fail_msg: The {{ rabbitmq_vol_storageclass }} StorageClass must be available on the cluster
    when: rabbitmq_vol_storageclass != " "

  - name: Create RabbitMQ volume claim ({{ rabbitmq_vol_storageclass }})
    k8s:
      definition: "{{ lookup('template', 'pvc-rabbitmq.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"

  # Best practice ... wait for the PVC to bind.
  # e.g. wait until resources[0].status.phase == Bound (initially Pending)

  - name: Wait for RabbitMQ volume claim to bind
    kubernetes.core.k8s_info:
      kind: PersistentVolumeClaim
      name: rabbitmq-data
      namespace: "{{ infra_namespace }}"
    register: rabbitmq_pvc_result
    until: >-
      rabbitmq_pvc_result.resources|length > 0
      and rabbitmq_pvc_result.resources[0].status is defined
      and rabbitmq_pvc_result.resources[0].status.phase is defined
      and rabbitmq_pvc_result.resources[0].status.phase == 'Bound'
    delay: 5
    retries: "{{ (bind_timeout|int / 5)|int }}"
    when: wait_for_bind|bool

  - name: RabbitMQ
    k8s:
      definition: "{{ lookup('template', '{{ item }}.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    loop:
    - configmap-rabbitmq-conf
    - service-rabbitmq
    - statefulset-rabbitmq

  - name: Wait for RabbitMQ to become Ready ({{ wait_timeout }} seconds)
    kubernetes.core.k8s_info:
      kind: Pod
      name: rabbitmq-0
      namespace: "{{ infra_namespace }}"
    register: rabbitmq_result
    until: >-
      rabbitmq_result.resources|length == 1
      and rabbitmq_result.resources[0].status is defined
      and rabbitmq_result.resources[0].status.containerStatuses is defined
      and rabbitmq_result.resources[0].status.containerStatuses|length == 1
      and rabbitmq_result.resources[0].status.containerStatuses[0].ready
    delay: 30
    retries: "{{ (wait_timeout|int / 30)|int }}"

  - name: Install RabbitMQ Ingress
    k8s:
      definition: "{{ lookup('template', 'ingress-rabbitmq.yaml.j2') }}"
      wait: yes
      wait_timeout: "{{ wait_timeout }}"
    when: rabbitmq_hostname|string|length > 0

  when: rabbitmq_state|string == 'present'
